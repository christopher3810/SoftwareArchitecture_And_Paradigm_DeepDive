## 데이터 스케일링과 신뢰성의 기원

### 단일 장치에서 분산 아키텍처로의 전환

---

## 서론: 데이터 폭증과 저장 시스템의 근본적 도전

현대 컴퓨팅 환경에서 데이터의 폭발적인 증가는 저장 시스템의 **성능**, **신뢰성**, 그리고 **무한한 확장성**에 대한 근본적인 도전을 제기해 왔다.

초창기 엔터프라이즈 컴퓨팅 환경은 단일 대형 고가용성 디스크(SLED, Single Large Expensive Disk)에 의존하여 데이터를 저장하고 관리했으나, 이는 하드웨어의 물리적 한계와 비용 효율성이라는 장벽에 부딪혔다.

이러한 한계를 극복하기 위해 엔지니어링 커뮤니티는 데이터를 물리적, 논리적으로 분산하여 처리하는 다양한 기법을 고안해 냈으며, 그 역사적 궤적의 중심에는 다음 세 가지 핵심 기술이 자리 잡고 있다.

- RAID (Redundant Array of Independent Disks)
    
- 데이터베이스 파티셔닝 (Partitioning)
    
- 데이터베이스 샤딩 (Sharding)
    

> [!IMPORTANT]  
> 이 기술들은 단순히 데이터를 나누는 행위를 넘어  
> **하드웨어의 물리적 한계를 소프트웨어 아키텍처와 논리적 구조로 극복하려는 지속적인 시도의 산물**이다.

RAID는 물리적 디스크 계층에서 데이터 가용성과 I/O 성능을 결합하였고,  
파티셔닝은 단일 데이터베이스 인스턴스 내에서 거대 테이블의 관리 효율성을 극대화했으며,  
샤딩은 다수의 서버로 부하를 분산하여 수평적 확장을 실현했다.

본 보고서에서는 이 세 가지 기술의 **개념적 정의**, **역사적 배경**, **해결하려는 핵심 문제**, **현대적 적용 사례**, 그리고 **도입 시의 전략적 고려사항**을 심층적으로 분석한다.

---

## 물리적 데이터 보호의 근간: RAID 기술의 심층 분석

### RAID의 탄생 배경과 역사적 맥락

RAID 기술은 1987년 캘리포니아 대학교 버클리 캠퍼스의  
David A. Patterson, Garth Gibson, Randy H. Katz가 발표한 논문  
_A Case for Redundant Arrays of Inexpensive Disks (RAID)_ 에서 시작되었다.

당시 메인프레임 시장을 장악하고 있던 고가의 단일 디스크(SLED)는 성능 향상 속도가 느리고 가격이 매우 높았다.  
Patterson 교수는 저렴한 개인용 컴퓨터급 디스크들을 병렬로 배열하여 사용함으로써, 고가의 디스크보다 뛰어난 성능과 신뢰성을 확보할 수 있다고 주장했다.

초기 명칭의 _Inexpensive_는 이후 기업용 시장의 요구에 맞춰 _Independent_로 변경되었으나,  
그 본질적인 아이디어인 **저렴한 자원의 집합을 통한 고성능 구현**은 현대 분산 시스템의 철학으로 이어지고 있다.

---

### RAID의 핵심 메커니즘: 미러링, 스트라이핑, 패리티

RAID는 세 가지 핵심 기술적 수단을 통해 데이터 저장소의 문제를 해결한다.

1. **미러링 (Mirroring)**  
    데이터를 두 개 이상의 디스크에 동일하게 복제하여 저장하는 방식이다.  
    하나의 디스크가 고장 나더라도 복제본을 통해 즉시 서비스를 지속할 수 있는 완전한 가용성을 제공한다.
    
2. **스트라이핑 (Striping)**  
    데이터를 일정한 블록 단위로 나누어 여러 디스크에 분산하여 저장하는 방식이다.  
    I/O 요청을 여러 디스크에서 동시에 처리함으로써 읽기 및 쓰기 대역폭을 비약적으로 향상시킨다.
    
3. **오류 교정 및 패리티 (Error Correction & Parity)**  
    데이터의 논리적 연산(XOR) 결과인 패리티 비트를 별도의 영역에 저장하여,  
    특정 디스크 장애 시 남은 데이터와 패리티를 조합해 손실된 데이터를 수학적으로 복구한다.
    

---

### RAID 수준별 특성 및 아키텍처 비교

|RAID 수준|기술적 구성|장점|단점|데이터 보호 방식|
|---|---|---|---|---|
|RAID 0|순수 스트라이핑|최상의 성능, 용량 효율 100%|장애 내성 없음|없음|
|RAID 1|순수 미러링|높은 신뢰성, 빠른 읽기|저장 효율 50%|데이터 복제|
|RAID 2|비트 스트라이핑 + Hamming|오류 정정 가능|현재 단종|Hamming ECC|
|RAID 3|바이트 스트라이핑 + 전용 패리티|연속 I/O 우수|패리티 병목|전용 패리티|
|RAID 4|블록 스트라이핑 + 전용 패리티|읽기 성능 우수|쓰기 병목|전용 패리티|
|RAID 5|블록 스트라이핑 + 분산 패리티|균형 잡힘|Rebuild 비용|분산 패리티|
|RAID 6|이중 분산 패리티|2중 장애 허용|쓰기 오버헤드|이중 패리티|
|RAID 10|미러링 후 스트라이핑|고성능·고가용성|고비용|중첩 구조|

RAID 5와 RAID 6에서 핵심이 되는 패리티 연산은 XOR 논리를 기반으로 한다.

- 패리티 계산:  
    `P = D1 ⊕ D2 ⊕ D3`
    
- 장애 복구:  
    `D2 = D1 ⊕ D3 ⊕ P`
    

이러한 수학적 특성은 **물리적 하드웨어의 불안정성을 논리적으로 보완**하는 스토리지 공학의 핵심으로 평가된다.

---

### 현대적 응용: 클라우드 스토리지와 RAID의 추상화

전통적으로 RAID는 서버 내부의 전용 하드웨어 컨트롤러에 의해 관리되었으나,  
현대의 클라우드 환경에서는 이 개념이 가상화 및 분산 아키텍처로 확장되었다.

- AWS EBS: 내부 다중 복제를 통한 고가용성
    
- 성능 요구 시 EBS 여러 개를 RAID 0으로 구성
    
- Amazon Aurora:
    
    - 데이터를 10GB 단위 보호 그룹으로 분할
        
    - 3개 AZ에 걸쳐 6중 복제
        
    - 쿼럼 기반 읽기·쓰기
        

> [!NOTE]  
> 이는 RAID의 핵심 사상인  
> **중복성을 통한 신뢰성 확보**가 네트워크 단위로 확장된 결과다.

---

## 논리적 데이터 관리의 정점: 데이터베이스 파티셔닝

### 파티셔닝의 개념과 해결하려는 문제

데이터베이스 파티셔닝은 단일 데이터베이스 서버 내에서  
거대해진 테이블을 관리 가능한 작은 단위인 **파티션**으로 분할하는 기법이다.

데이터가 수억 건을 넘어가면 다음 문제가 발생한다.

- 인덱스가 메모리를 초과
    
- 쿼리 성능 급락
    
- 관리 작업 비용 증가
    

파티셔닝은 이를 **논리적 분할**로 해결한다.

---

### 파티셔닝의 주요 유형

1. **수평적 파티셔닝**  
    행(Row) 기준 분할  
    대표적으로 Range Partitioning 사용
    
2. **수직적 파티셔닝**  
    열(Column) 기준 분할  
    BLOB, 변경 빈도 기준 분리
    

---

### 파티셔닝의 실무적 이점

> [!IMPORTANT]  
> 파티셔닝의 핵심 가치는  
> **Partition Pruning** 이다.

- 옵티마이저가 불필요한 파티션 제외
    
- 디스크 I/O 급감
    
- 대량 DELETE 대신 DROP PARTITION 가능
    

---

### 파티셔닝의 한계

> [!WARNING]  
> 파티셔닝은 **단일 서버 최적화 기술**이다.

- 서버 물리 한계는 그대로 존재
    
- 잘못된 키 선택 시 데이터 스큐 발생
    
- Cross-partition Join 비용 증가
    

---

## 수평적 확장의 궁극적 해결책: 데이터베이스 샤딩

### 샤딩의 정의와 역사적 부상

샤딩은 데이터를 여러 대의 독립적인 서버에 분산 저장하는 아키텍처다.  
2000년대 중반 웹 서비스 급성장과 함께 필수 기술로 자리 잡았다.

YouTube는 MySQL 확장 한계를 극복하기 위해 Vitess를 개발해 대규모 샤딩 운영을 실현했다.

---

### 샤딩의 아키텍처 구성 요소

1. 샤드 키
    
2. 샤드 맵 및 라우팅 레이어
    
3. 데이터 노드
    

---

### 주요 샤딩 전략

|전략|장점|단점|
|---|---|---|
|Range|범위 조회 효율|핫스팟|
|Hash|균등 분산|범위 조회 불가|
|Geo|지연 최소화|운영 복잡|
|Entity|Join 최소화|엔티티 스큐|

---

### 샤딩의 효과

- 거의 선형적 확장
    
- 장애 격리
    
- 대규모 트래픽 처리 가능
    

---

## 분산 환경의 정합성 난제

### 분산 트랜잭션

- **2PC**: 강한 일관성, 낮은 확장성
    
- **Saga**: 결과적 일관성, 높은 처리량
    

---

### Cross-shard Join 문제

- 역정규화
    
- Reference Table
    
- 애플리케이션 레벨 조인
    

---

## 기술적 도전과 운영상의 고민사항

### 샤드 키 선정의 중요성

> [!WARNING]  
> 샤드 키는 되돌리기 어렵다.  
> 잘못된 선택은 전체 성능을 붕괴시킨다.

---

### 운영 복잡도 증가

- 백업
    
- 모니터링
    
- 스키마 변경
    
- 보안 패치
    

자동화 없이는 불가능한 영역이다.

---

### 재샤딩의 위험성

재샤딩은 서비스 무중단을 요구하며,  
데이터 정합성 검증이 필수다.

Vitess, Citus는 이를 최소 다운타임으로 지원하지만  
여전히 고난도 작업이다.

---

## 아키텍처의 미래: NewSQL과 관리형 서비스

### Google Spanner

- TrueTime API
    
- 전역적 일관성
    
- 글로벌 SQL
    

### AWS Aurora Limitless

- Write scale-out
    
- Serverless shard
    
- 정책 기반 자동 확장
    

---

## 요약 및 결론

- RAID: 물리적 안정성
    
- 파티셔닝: 단일 DB 수명 연장
    
- 샤딩: 최후의 확장 수단
    

> [!IMPORTANT]  
> 조기 샤딩은 기술 부채가 된다.

미래의 데이터베이스는 복잡성을 숨기겠지만,  
**분산과 정합성의 원리는 변하지 않는다.**
